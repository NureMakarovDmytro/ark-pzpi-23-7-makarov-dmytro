МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ
ФАКУЛЬТЕТ КОМП’ЮТЕРНИХ НАУК
КАТЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ


ЗВІТ
до практичного завдання №2
 з дисципліни
«Аналіз та рефакторинґ коду»
на тему: «Методи рефакторинґу коду програмного забезпечення: Remove Setting Method, Replace Exception with Test, Change Value to Reference»







Виконав:                                                                                                  Перевірив:
ст. гр. ПЗПІ-23-6                       				ст. викладач катедри Макаров Дмитро		                                                  Сокорчук Ігор Петрович






Харків 2025

2 ЗАВДАННЯ
Метою даної практичної роботи є поглиблене вивчення та практичне засвоєння методів рефакторинґу програмного забезпечення, спрямованих на покращення внутрішньої структури коду без зміни його зовнішньої поведінки, а також аналіз впливу цих перетворень на якість програмного продукту. У рамках роботи необхідно ознайомитися з фундаментальними підходами до рефакторинґу, описаними у праці Мартіна Фаулера, обрати три унікальні методи та продемонструвати їх застосування на фрагментах власного коду, написаного під час виконання попередніх навчальних завдань або курсових проєктів.
Студент повинен виявити у своєму коді ділянки, що містять так звані «запахи коду» або структурні недоліки, та усунути їх за допомогою обраних технік, підготувавши наочні приклади стану коду «до» та «після» внесених змін. Для кожного прикладу необхідно надати обґрунтування доцільності рефакторинґу, пояснивши суть проблеми, яку вирішує конкретний метод, та описати переваги отриманого рішення в контексті читабельності, гнучкості та простоти підтримки.
На основі проведеної роботи студент має підготувати презентацію, яка містить теоретичний вступ, детальний розбір трьох прикладів рефакторинґу, огляд можливостей автоматизованого рефакторинґу в сучасних інтегрованих середовищах розробки, а також висновки щодо важливості регулярного покращення кодової бази.









3 ОПИС ВИКОНАНОЇ РОБОТИ

3.1 Вибір мови програмування та джерел
Для виконання практичної роботи обрано три методи рефакторингу з класичного каталогу Мартіна Фаулера. Метою застосування цих технік є підвищення читабельності програмного коду, зменшення його складності та покращення архітектурної гнучкості. Всі приклади реалізовано мовою програмування Pascal.
До переліку обраних методів увійшли:
Remove Setting Method (видалення методів встановлення) – застосовується для перетворення змінюваних об’єктів на незмінні (immutable), усуваючи сеттери, якщо значення встановлюється лише при створенні.
Replace Exception with Test (заміна винятків перевіркою) – використовується для заміни обробки винятків на попередні перевірки умов, коли виняток використовується для керування потоком замість помилок.
Change Value to Reference (зміна значення на посилання) – дозволяє замінити численні копії об’єктів з однаковими даними на єдиний посилальний об’єкт, забезпечуючи ідентичність та узгодженість.

3.2 Метод Remove Setting Method (видалення методів встановлення)
Даний метод рефакторинґу застосовується, коли об’єкт дозволяє змінювати свої поля після створення, але на практиці ці зміни не потрібні або призводять до неконтрольованих станів. Видалення сеттерів робить об’єкт незмінним, що підвищує безпеку та полегшує розуміння коду.
У вихідній реалізації клас TEmployee дозволяв встановлювати ім’я та посаду після створення об’єкта. Це створювало ризик: об’єкт міг бути змінений у будь-який момент, що ускладнювало відстеження стану та могло призвести до помилок у багатокористувацьких сценаріях. Крім того, сеттери часто вказують на порушення принципу єдиної відповідальності.
TEmployee = class
private
FName: string;
FPosition: string;
public
constructor Create(initName, initPosition: string);
procedure SetName(newName: string);
procedure SetPosition(newPosition: string);
property Name: string read FName write SetName;
property Position: string read FPosition write SetPosition;
end;
constructor TEmployee.Create(initName, initPosition: string);
begin
FName := initName;
FPosition := initPosition;
end;
procedure TEmployee.SetName(newName: string);
begin
FName := newName;
end;
В результаті рефакторинґу сеттери та відповідні записи у властивостях видалено. Всі значення тепер передаються виключно у конструкторі. Об’єкт став незмінним, що гарантує стабільність стану після створення. Це спростило використання класу та усунуло потенційні баги, пов’язані з пізніми змінами.
TEmployee = class
private
FName: string;
FPosition: string;
public
constructor Create(initName, initPosition: string);
property Name: string read FName;
property Position: string read FPosition;
end;
constructor TEmployee.Create(initName, initPosition: string);
begin
FName := initName;
FPosition := initPosition;
end;

3.3 Метод Replace Exception with Test (заміна винятків перевіркою)
Даний метод рефакторинґу застосовується, коли винятки використовуються не для обробки помилок, а для звичайного керування потоком програми. Заміна на попередню перевірку робить код більш передбачуваним та ефективним.
У початковому коді для отримання працівника за ID використовувався виняток EEmployeeNotFound, який генерувався, якщо працівника не знайдено. Це призводило до зайвого використання механізму винятків для очікуваної ситуації, що знижувало продуктивність та ускладнювало читання коду.
function GetEmployeeById(id: Integer): TEmployee;
begin
if not Employees.TryGetValue(id, Result) then
raise EEmployeeNotFound.Create('Працівник не знайдений');
end;
try
emp := GetEmployeeById(42);
Writeln(emp.Name);
except
on E: EEmployeeNotFound do
Writeln('Працівник відсутній');
end;
В результаті рефакторинґу виняток замінено на попередню перевірку з булевим результатом. Функція тепер повертає True/False та заповнює параметр-результат лише за успіху. Це усунуло накладні витрати на винятки та зробило логіку явною.
function TryGetEmployeeById(id: Integer; out emp: TEmployee): Boolean;
begin
Result := Employees.TryGetValue(id, emp);
end;
if TryGetEmployeeById(42, emp) then
Writeln(emp.Name)
else
Writeln('Працівник відсутній');

3.4 Метод Change Value to Reference (зміна значення на посилання)
Цей метод рефакторинґу передбачає заміну створення численних ідентичних об’єктів-значень на використання єдиних посилальних екземплярів з репозиторію. Це забезпечує ідентичність об’єктів та узгодженість даних.
У вихідному коді для кожного департаменту створювався новий об’єкт TDepartment навіть за однакової назви. Це призводило до ситуації, коли два працівники могли мати «різні» департаменти з однаковою назвою, що ускладнювало порівняння та порушувало принцип єдиної істини.
TDepartment = class
private
FName: string;
public
constructor Create(AName: string);
property Name: string read FName;
end;
emp1.Department := TDepartment.Create('IT');
emp2.Department := TDepartment.Create('IT');
if emp1.Department = emp2.Department then // False, хоча назви однакові
В результаті рефакторинґу створено репозиторій департаментів, який повертає єдиний екземпляр для кожної назви. Тепер об’єкти департаментів є посиланнями на одні й ті ж інстанси, що дозволяє коректно порівнювати їх за посиланням та гарантує узгодженість.
TDepartmentRepository = class
private
FDepartments: TDictionary<string, TDepartment>;
public
function GetDepartment(const AName: string): TDepartment;
end;
function TDepartmentRepository.GetDepartment(const AName: string): TDepartment;
begin
if not FDepartments.TryGetValue(AName, Result) then
begin
Result := TDepartment.Create(AName);
FDepartments.Add(AName, Result);
end;
end;
emp1.Department := Repository.GetDepartment('IT');
emp2.Department := Repository.GetDepartment('IT');
if emp1.Department = emp2.Department then // True



4 ВИСНОВКИ

У ході виконання практичної роботи було досліджено та успішно застосовано фундаментальні методи рефакторингу коду на прикладі мови Pascal. Використання таких технік, як Remove Setting Method, Replace Exception with Test та Change Value to Reference, дозволило трансформувати складні, важкочитабельні фрагменти програмного забезпечення у гнучкі та зрозумілі структури. Зокрема, вдалося ефективно усунути поширені «запахи коду»: можливість неконтрольованої зміни стану об’єктів, неправильне використання винятків для керування потоком та дублювання ідентичних даних. Практичні приклади продемонстрували, що перехід до незмінних об’єктів, явних перевірок та посилальних структур значно підвищують безпеку, продуктивність та самодокументованість коду.


















ДОДАТОК А
Відеозапис доповіді: https://youtu.be/ApO_t-8tJVw
Хронологічний опис відеозапису:
0:00 – Вступ
1:15 – Призначення рефакторинґу
2:10 – Інструменти для рефакторинґу
3:20 – Огляд обраних методів рефакторинґу
4:45 – Метод рефакторинґу Remove Setting Method
7:10 – Метод рефакторинґу Replace Exception with Test
9:00 – Метод рефакторинґу Change Value to Reference
11:20 – Висновки



















ДОДАТОК Б
Слайди презентації
  
Рисунок Б.1 – Титульний слайд презентації

Рисунок Б.2 – Визначення рефакторинґу

Рисунок Б.3 – Призначення рефакторинґу

Рисунок Б.4 – Інструменти для рефакторинґу




Рисунок Б.5 – Огляд обраних методів рефакторинґу

Рисунок Б.6 – Код до рефакторинґу методом Remove Setting Method





Рисунок Б.7 – Код після рефакторинґу методом Remove Setting Method

Рисунок Б.8 – Код до рефакторинґу методом Replace Exception with Test




 
Рисунок Б.9 – Код після рефакторинґу методом Replace Exception with Test
 
Рисунок Б.10 – Код до рефакторинґу методом Change Value to Reference





 
Рисунок Б.11 – Код після рефакторинґу методом Change Value to Reference

 
Рисунок Б.12 – Висновки




 
Рисунок Б.13 – Список використаних джерел
